from math import *
import numpy as np
from scipy.optimize import fsolve


class RP1D_Euler:
    """
    Solve the Riemann problem for the one-dimensional Euler equations.

    Solve the Riemann problem exactly for the one-dimensional Euler equations
    with an ideal gas equation of state and provided left and right states.
    The solution is based on the algorithm given in Chap. 4 of [1]_ and the
    provided FORTRAN code.

    Parameters
    ----------
    gamma : float
        Ideal gas ratio of specific heats, aka adiabatic exponent
    dL, dR : float
        Left/right density
    uL, uR : float
        Left/right velocity
    pL, pR : float
        Left/right pressure
    xdiaph : float
        Position of diaphragm

    Attributes
    ----------
    dL, dR : float
        Left/right density
    uL, uR : float
        Left/right velocity
    pL, pR : float
        Left/right pressure
    xdiaph : float
        Position of diaphragm

    Raises
    ------
    ValueError
        The given Riemann problem generates vacuum states.

    Notes
    -----
    Not all attributes are documented... They are anyway of no direct use!

    References
    ----------
    .. [1] E. F. Toro, "Riemann Solvers and Numerical Methods for Fluid
       Dynamics", Springer-Verlag, Third Edition, 2009.

    """

    def __init__(self, gamma, densL, velL, presL, densR, velR, presR,
                 xdiaph=0.):

        # set various attributes
        self.dL = densL
        self.dR = densR
        self.uL = velL
        self.uR = velR
        self.pL = presL
        self.pR = presR
        self.xdiaph = xdiaph
        self.cL = sqrt(gamma * presL / densL)
        self.cR = sqrt(gamma * presR / densR)
        self._g0 = gamma
        self._g1 = 0.5 * (gamma - 1.) / gamma
        self._g2 = 0.5 * (gamma + 1.) / gamma
        self._g3 = 2. * gamma / (gamma - 1.)
        self._g4 = 2. / (gamma - 1.)
        self._g5 = 2. / (gamma + 1.)
        self._g6 = (gamma - 1.) / (gamma + 1.)
        self._g7 = 0.5 * (gamma - 1.)

        # check pressure positivity
        if self._g4 * (self.cL + self.cR) < self.uR - self.uL:
            raise ValueError("Vacuum is generated by given states!")

        # determine star region pressure & velocity
        self.pM = self._get_pstar()
        self.uM = self._get_ustar(self.pM)

        # get left  wave head and tail speeds, and left  star state
        if self.pM <= self.pL:  # left  rarefaction
            # head and tail speeds
            self.SHL = self.uL - self.cL
            self.STL = self.uM - self.cL * (self.pM / self.pL) ** self._g1
            # star density
            self.dML = self.dL * (self.pM / self.pL) ** (1. / self._g0)
        else:  # left  shock
            # head and tail speeds
            prat = self.pM / self.pL
            self.SHL = self.uL - self.cL * sqrt(self._g2 * prat + self._g1)
            self.STL = self.SHL
            # star density
            self.dML = self.dL * (prat + self._g6) / (prat * self._g6 + 1.)
        self.uML = self.uM
        self.pML = self.pM

        # get right wave head and tail speeds
        if self.pM <= self.pR:  # right rarefaction
            self.SHR = self.uR + self.cR
            self.STR = self.uM + self.cR * (self.pM / self.pR) ** self._g1
            # star density
            self.dMR = self.dR * (self.pM / self.pR) ** (1. / self._g0)
        else:  # right shock
            prat = self.pM / self.pR
            self.SHR = self.uR + self.cR * sqrt(self._g2 * prat + self._g1)
            self.STR = self.SHR
            # star density
            self.dMR = self.dR * (prat + self._g6) / (prat * self._g6 + 1.)
        self.uMR = self.uM
        self.pMR = self.pM

    def sample(self, x, t):
        """
        Sample the solution to the Riemann problem.

        Parameters
        ----------
        x : float or array_like
            Position(s) where to sample the Riemann problem solution
        t : float
            Time when to sample the Riemann problem solution

        Returns
        -------
        d : float or array_like
            Density at position(s) `x`
        u : float or array_like
            Velocity at position(s) `x`
        p : float or array_like
            Pressure at position(s) `x`
        """

        # convert input to array
        ScalarInput = np.isscalar(x)
        x = np.asarray(x)
        # distinguish states
        if t > 0.:
            s = (x - self.xdiaph) / t
            in_L = s < self.SHL
            in_IL = np.logical_and(self.SHL <= s, s < self.STL)
            in_ML = np.logical_and(self.STL <= s, s < self.uM)
            in_MR = np.logical_and(self.uM <= s, s < self.STR)
            in_IR = np.logical_and(self.STR <= s, s < self.SHR)
            in_R = self.SHR <= s
        else:
            s = x - self.xdiaph
            in_L = s < self.SHL * t
            in_IL = np.full_like(s, False, dtype=bool)
            in_ML = np.full_like(s, False, dtype=bool)
            in_MR = np.full_like(s, False, dtype=bool)
            in_IR = np.full_like(s, False, dtype=bool)
            in_R = self.SHR * t <= s
        # initialize and set density, velocity & pressure
        d = np.zeros_like(x)
        u = np.zeros_like(x)
        p = np.zeros_like(x)
        # left  state
        d[in_L] = self.dL
        u[in_L] = self.uL
        p[in_L] = self.pL
        # intermediate left  state, i.e. between head & tail of left  wave
        cIL = self._g5 * (self.cL + self._g7 * (self.uL - s[in_IL]))
        d[in_IL] = self.dL * (cIL / self.cL) ** self._g4
        u[in_IL] = self._g5 * (+ self.cL + self._g7 * self.uL + s[in_IL])
        p[in_IL] = self.pL * (cIL / self.cL) ** self._g3
        # left  star state
        d[in_ML] = self.dML
        u[in_ML] = self.uM
        p[in_ML] = self.pM
        # right star state
        d[in_MR] = self.dMR
        u[in_MR] = self.uM
        p[in_MR] = self.pM
        # intermediate right state, i.e. between head & tail of right wave
        cIR = self._g5 * (self.cR - self._g7 * (self.uR - s[in_IR]))
        d[in_IR] = self.dR * (cIR / self.cR) ** self._g4
        u[in_IR] = self._g5 * (- self.cR + self._g7 * self.uR + s[in_IR])
        p[in_IR] = self.pR * (cIR / self.cR) ** self._g3
        # right state
        d[in_R] = self.dR
        u[in_R] = self.uR
        p[in_R] = self.pR

        if ScalarInput:
            return d.item(), u.item(), p.item()
        else:
            return d, u, p

    def _get_pstar(self):
        """Get pressure in star region"""
        p0 = self._guess_pstar()
        pstar = fsolve(self._f, p0)[0]
        return pstar

    def _get_ustar(self, pstar):
        """Get velocity in star region"""
        ustar = 0.5 * (self.uL + self.uR + self._fR(pstar) - self._fL(pstar))
        return ustar

    def _guess_pstar(self):
        """Provide initial guess of the star region pressure using the
           PVRS, TRRS and TSRS approximate Riemann solvers"""
        quser = 2.
        cup = 0.25 * (self.dL + self.dR) * (self.cL + self.cR)
        ppv = max(0.5 * (self.pL + self.pR) - 0.5 * (self.uR - self.uL) * cup, 0.)
        pmin = min(self.pL, self.pR)
        pmax = max(self.pL, self.pR)
        qmax = pmax / pmin
        if (qmax <= quser) and (pmin <= ppv and ppv <= pmax):  # select PVRS
            # approx.
            # Riemann solver
            pm = ppv
        else:
            if ppv < pmin:  # select two-rarefaction approx. Riemann solver
                pq = (self.pL / self.pR) ** self._g1
                um = (pq * self.uL / self.cL + self.uR / self.cR
                      + self._g4 * (pq - 1.0)) / (pq / self.cL + 1. / self.cR)
                ptL = 1. + self._g7 * (self.uL - um) / self.cL
                ptR = 1. + self._g7 * (um - self.uR) / self.cR
                pm = 0.5 * (self.pL * ptL ** self._g3 + self.pR * ptR ** self._g3)
            else:  # select two-shock approx. Riemann solver
                geL = sqrt((self._g5 / self.dL) / (self._g6 * self.pL + ppv))
                geR = sqrt((self._g5 / self.dR) / (self._g6 * self.pR + ppv))
                pm = (geL * self.pL + geR * self.pR - (self.uR - self.uL)) \
                     / (geL + geR)
        return pm

    def _fL(self, pres):
        """Evaluate pressure function with left state"""
        return self._fK(pres, self.dL, self.pL, self.cL)

    def _fR(self, pres):
        """Evaluate pressure function with right state"""
        return self._fK(pres, self.dR, self.pR, self.cR)

    def _fK(self, pres, dK, pK, cK):
        """Evaluate left/right pressure function"""
        if pres <= pK:  # rarefaction wave
            prat = pres / pK
            f = self._g4 * cK * (prat ** self._g1 - 1.)
        else:  # shock wave
            aK = self._g5 / dK
            bK = self._g6 * pK
            qrt = sqrt(aK / (bK + pres))
            f = (pres - pK) * qrt
        return f

    def _f(self, pres):
        """Evaluate pressure function"""
        du = self.uR - self.uL
        f = self._fL(pres) + self._fR(pres) + du
        return f


def print_rp(RP):
    """Print Riemann problem star pressure and velocity values"""
    print(f"p* = {RP.pM:+12.5f}, u* = {RP.uM:+12.5f}, "
          f"p*L = {RP.dML:+12.5f}, p*R = {RP.dMR:+12.5f}")


def plot_rp(RP, x, t):
    """Plot Riemann problem"""
    import matplotlib.pyplot as plt
    d, u, p = RP.sample(x, t)
    plt.clf()
    plt.subplot(3, 1, 1)
    plt.title(f"Riemann problem at time {t}")
    plt.plot(x, d)
    plt.xlim(min(x), max(x))
    plt.xlabel("x")
    plt.ylabel("Density")
    plt.subplot(3, 1, 2)
    plt.plot(x, u)
    plt.xlim(min(x), max(x))
    plt.xlabel("x")
    plt.ylabel("Velocity")
    plt.subplot(3, 1, 3)
    plt.plot(x, p)
    plt.xlim(min(x), max(x))
    plt.xlabel("x")
    plt.ylabel("Pressure")
    plt.show()


if __name__ == "__main__":
    # The following Riemann problems should reproduce the examples provided
    # in Chap. 4 of [1]_.
    gamma = 1.4
    x = np.linspace(-0.5, +0.5, 1000)
    RP1 = RP1D_Euler(gamma, 1., 0., 1., 0.125, 0., 0.1)
    print_rp(RP1)
    plot_rp(RP1, x, 0.25)
    RP2 = RP1D_Euler(gamma, 1., -2., 0.4, 1., +2., 0.4)
    print_rp(RP2)
    plot_rp(RP2, x, 0.15)
    RP3 = RP1D_Euler(gamma, 1., 0., 1000., 1., 0., 0.01)
    print_rp(RP3)
    plot_rp(RP3, x, 0.012)
    RP4 = RP1D_Euler(gamma, 1., 0., 0.01, 1., 0., 100.)
    print_rp(RP4)
    plot_rp(RP4, x, 0.035)
    RP5 = RP1D_Euler(gamma, 5.99924, 19.5975, 460.894, 5.99242, -6.19633,
                     46.0950)
    print_rp(RP5)
    plot_rp(RP5, x, 0.035)
